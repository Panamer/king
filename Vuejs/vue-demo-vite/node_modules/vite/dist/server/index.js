"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const koa_1 = __importDefault(require("koa"));
const chokidar_1 = __importDefault(require("chokidar"));
const resolver_1 = require("../resolver");
const serverPluginModuleRewrite_1 = require("./serverPluginModuleRewrite");
const serverPluginModuleResolve_1 = require("./serverPluginModuleResolve");
const serverPluginVue_1 = require("./serverPluginVue");
const serverPluginHmr_1 = require("./serverPluginHmr");
const serverPluginServeStatic_1 = require("./serverPluginServeStatic");
const serverPluginJson_1 = require("./serverPluginJson");
const serverPluginCss_1 = require("./serverPluginCss");
const serverPluginAssets_1 = require("./serverPluginAssets");
const serverPluginEsbuild_1 = require("./serverPluginEsbuild");
const transform_1 = require("../transform");
const serverPluginServiceWorker_1 = require("./serverPluginServiceWorker");
const serverPluginHtml_1 = require("./serverPluginHtml");
const serverPluginProxy_1 = require("./serverPluginProxy");
const createCertificate_1 = require("../utils/createCertificate");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
var serverPluginModuleRewrite_2 = require("./serverPluginModuleRewrite");
exports.rewriteImports = serverPluginModuleRewrite_2.rewriteImports;
function createServer(config) {
    const { root = process.cwd(), configureServer = [], resolvers = [], alias = {}, transforms = [], vueCustomBlockTransforms = {}, optimizeDeps = {} } = config;
    const app = new koa_1.default();
    const server = resolveServer(config, app.callback());
    const watcher = chokidar_1.default.watch(root, {
        ignored: [/node_modules/]
    });
    const resolver = resolver_1.createResolver(root, resolvers, alias);
    const context = {
        root,
        app,
        server,
        watcher,
        resolver,
        config
    };
    // attach server context to koa context
    app.use((ctx, next) => {
        Object.assign(ctx, context);
        return next();
    });
    const resolvedPlugins = [
        // the import rewrite and html rewrite both take highest priority and runs
        // after all other middlewares have finished
        serverPluginModuleRewrite_1.moduleRewritePlugin,
        serverPluginHtml_1.htmlRewritePlugin,
        // user plugins
        ...(Array.isArray(configureServer) ? configureServer : [configureServer]),
        serverPluginModuleResolve_1.moduleResolvePlugin,
        serverPluginProxy_1.proxyPlugin,
        serverPluginServiceWorker_1.serviceWorkerPlugin,
        serverPluginHmr_1.hmrPlugin,
        ...(transforms.length || Object.keys(vueCustomBlockTransforms).length
            ? [transform_1.createServerTransformPlugin(transforms, vueCustomBlockTransforms)]
            : []),
        serverPluginVue_1.vuePlugin,
        serverPluginCss_1.cssPlugin,
        serverPluginEsbuild_1.esbuildPlugin,
        serverPluginJson_1.jsonPlugin,
        serverPluginAssets_1.assetPathPlugin,
        serverPluginServeStatic_1.serveStaticPlugin
    ];
    resolvedPlugins.forEach((m) => m(context));
    const listen = server.listen.bind(server);
    server.listen = (async (...args) => {
        if (optimizeDeps.auto !== false) {
            await require('../optimizer').optimizeDeps(config);
        }
        return listen(...args);
    });
    return server;
}
exports.createServer = createServer;
function resolveServer({ https = false, httpsOption = {} }, requestListener) {
    if (https) {
        return require('https').createServer(resolveHttpsConfig(httpsOption), requestListener);
    }
    else {
        return require('http').createServer(requestListener);
    }
}
function resolveHttpsConfig(httpsOption) {
    const { ca, cert, key, pfx } = httpsOption;
    Object.assign(httpsOption, {
        ca: readFileIfExits(ca),
        cert: readFileIfExits(cert),
        key: readFileIfExits(key),
        pfx: readFileIfExits(pfx)
    });
    if (!httpsOption.key || !httpsOption.cert) {
        httpsOption.cert = httpsOption.key = createCertificate_1.createCertificate();
    }
    return httpsOption;
}
function readFileIfExits(value) {
    if (value && !Buffer.isBuffer(value)) {
        try {
            return fs_extra_1.default.readFileSync(path_1.default.resolve(value));
        }
        catch (e) {
            return value;
        }
    }
    return value;
}
//# sourceMappingURL=index.js.map